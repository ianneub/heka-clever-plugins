-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

--[=[
Extracts data from message fields in messages generated by a
and generates JSON suitable for use with the Librato
's `HTTP API <http://dev.librato.com/v1>`_.

Config:

- ignore_fields (string, optional, defaults to "")
    A `,` seperated list of Fields that will be omitted when creating the metric name
    eg. "extra,hostname" will ignore fields called `extra` and `hostname` from the metric name

*Example Heka Configuration*

.. code-block:: ini

    [librato-encoder]
    type = "SandboxEncoder"
    filename = "lua_encoders/schema_librato.lua"
       [librato-encoder.config]
       ignore_fields = "level,hostname"

    [librato]
    type = "HttpOutput"
    message_matcher = "Type == 'heka.statmetric'"
    address = "https://metrics-api.librato.com/v1/metrics"
    encoder = "librato-encoder"
    username = "librato_username"
    password = "librato_api_key"

*Example Output*

.. code-block:: json

    {"gauges":{ "time_taken.video_encoding.mpeg" : {"value":441267,"measure_time":1417413408,"source":"0a5a7339e657"}}}

--]=]

require "cjson"
require "table"
require "string"


local stat_types = {
    gauge = "gauges",
    gauges = "gauges",
    counter = "counters",
    counters = "counters"
}
local ignore_fields_config = read_config("ignore_fields") or 'level'

local ignore_fields = { value = true, type = true}
for f in string.gmatch(ignore_fields_config, '([^,]+)') do
    if f ~= "" and f ~= nil then
        ignore_fields[f] = true
    end
end


function metric_name()
    local field_names = {}

    while true do
        typ, name, value, representation, count = read_next_field()
        if not typ then break end
        if ignore_fields[name] == nil then
            table.insert(field_names, name)
        end
    end
    table.sort(field_names)

    local names = {}
    for _, field in pairs(field_names) do
        local val = read_message("Fields[".. field .."]")
        if val then
            table.insert(names, val)
        end
    end

    return table.concat(names, '.')
end

function process_message()
    local ts = read_message("Timestamp") / 1e9
    local hostname = read_message("Hostname")

    local stat_type = stat_types[read_message("Fields[type]")]
    local value = read_message("Fields[value]")

    if not ts or not value then
        return -1
    end
    if not stat_type then return -1 end
    -- only process name if everything looks good
    local name = metric_name()
    if not name or name == "" then return -1 end

    local output = {
        [stat_type] = {
            [name] = {
                value = value,
                source = hostname,
                measure_time = ts
            }
        }
    }

    inject_payload("json", "librato_stats", cjson.encode(output))
    return 0
end
