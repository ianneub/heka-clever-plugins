-- This Source Code Form is subject to the terms of the Mozilla Public
-- License, v. 2.0. If a copy of the MPL was not distributed with this
-- file, You can obtain one at http://mozilla.org/MPL/2.0/.

--[=[
Extracts data from message fields in `heka.statmetric` messages generated by a
:ref:`config_stat_accum_input` and generates JSON suitable for use with the Librato
's `HTTP API
<http://dev.librato.com/v1>`_.
StatAccumInput must be configured with `emit_in_fields = true` for this
encoder to work correctly. As of now, this encoder assumes that stats prefixes 
`global_prefix` and `statsd_prefix` are set to their defaults.

Config:

<none>

*Example Heka Configuration*

.. code-block:: ini

    [statmetric-librato-encoder]
    type = "SandboxEncoder"
    filename = "lua_encoders/statmetric_librato.lua"

    [influx]
    type = "HttpOutput"
    message_matcher = "Type == 'heka.statmetric'"
    address = "https://metrics-api.librato.com/v1/metrics"
    encoder = "statmetric-librato-encoder"
    username = "librato_username"
    password = "librato_api_key"

*Example Output*

.. code-block:: json

    [{"value":441267,"measure_time":1417413408,"name":"stats.gauges.servers.docker-trusty.diskspace.root.inodes_used","source":"0a5a7339e657"}]

--]=]

require "cjson"
require "table"
require "string"

function parse_metric (name)
    _, _, kind, hostname, metric_name = string.find(name, "^stats.(.-).(.-).(.*)$")
    inject_message({ kind = kind, hostname = hostname, metric_name = metric_name, name = name})
    if kind == "statsd" then
        -- this is an internal hekad metric
        metric_name = hostname
        hostname = nil
        kind = "counters"
    end
    if metric_name == nil or metric_name == "" then
        return nil
    end

    return kind, hostname, metric_name
end


function process_message()
    local output = { gauges = {}, counters = {} }
    local ts = tonumber(read_message("Fields[timestamp]"))
    local message_host = read_message("Hostname")
    if not ts then return -1 end
    while true do
        typ, name, value, representation, count = read_next_field()
        if not typ then break end

        if name ~= "timestamp" and typ ~= 1 then -- exclude bytes
            kind, hostname, metric_name = parse_metric(name)

            local stat = {
                name = metric_name,
                value = value,
                source = hostname or message_host,
                measure_time = ts,
            }
            table.insert(output[kind], stat)
        end
    end
    inject_payload("json", "librato_stats", cjson.encode(output))
    return 0
end
